/***************************************************************
  BayCom(R)        Packet-Radio fuer IBM PC

  OpenBCM-Mailbox

  --------------------------------------------------------------
  Serielle Ein/Ausgabe zum Anschluss eines Terminals unter Linux
  --------------------------------------------------------------


  Copyright (C)       Florian Radlherr
                      Taubenbergstr. 32
                      83627 Warngau

  Alle Rechte vorbehalten / All Rights Reserved

 ***************************************************************/

#include "baycom.h"

#ifdef FEATURE_SERIAL

#include <sys/ioctl.h>
#include <fcntl.h>
#include <termios.h>

/*---------------------------------------------------------------------------*/

#define PUTBUF 100
static char putbuf[PUTBUF];
unsigned int putbufindex = 0;

/*---------------------------------------------------------------------------*/

static int rxcbuf;
static int rxdafl;
static int ttyfd = EOF;

/*---------------------------------------------------------------------------*/

static int near holtty (void)
//*************************************************************************
//
//*************************************************************************
{
  char c;
  if (read(ttyfd, &c, 1) > 0) return c;
  else return EOF;
}

/*---------------------------------------------------------------------------*/

int getv_tty (void)
//*************************************************************************
//
//*************************************************************************
{
  int tmp;
  if (rxdafl)
  {
    rxdafl = 0;
    return rxcbuf;
  }
  while (1)
  {
    tmp = holtty();
    if (tmp != EOF) return tmp;
    wdelay(14);
  }
}

/*---------------------------------------------------------------------------*/

int getvalid_tty (void)
//*************************************************************************
//
//*************************************************************************
{
  int tmp;
  if (rxdafl)
  {
    if (rxcbuf == CR) return CR;
    return OK;
  }
  if ((tmp = holtty()) != EOF)
  {
    rxcbuf = tmp;
    rxdafl = OK;
    if (tmp == CR) return CR;
    return OK;
  }
  return NO;
}

/*---------------------------------------------------------------------------*/

void inputline_tty (char *s, int maxlen, char cut)
//*************************************************************************
//
//*************************************************************************
{
  unsigned int i = 0;
  int semi = NO;

  if (maxlen < 0)
  {
    // db7mh semi = OK;
    maxlen = (-maxlen);
  }
  putflush_tty();
  while (1)
  {
    if ( /*! cut &&*/ i == (unsigned) maxlen) break;
    do s[i] = getv_tty();
    while (s[i] == CR);
    if (semi && s[i] == ';') break;
    if (s[i] == LF)
    {
      if (! cut) i++;
      break;
    }
    if (s[i] == 8)
    {
      if (i) i--;
      continue;
    }
    if (i < (unsigned) maxlen) i++;
  }
  s[i] = 0;
}

/*---------------------------------------------------------------------------*/

int putfree_tty (void)
//*************************************************************************
//
//*************************************************************************
{
  return 1;
}

/*---------------------------------------------------------------------------*/

void putv_tty (int ch)
//*************************************************************************
//
//*************************************************************************
{
  putbuf[putbufindex] = ch;
  putbufindex++;
  if (putbufindex == PUTBUF) putflush_tty();
}

/*---------------------------------------------------------------------------*/

void putflush_tty (void)
//*************************************************************************
//
//*************************************************************************
{
  if (putbufindex)
  {
    write(ttyfd, putbuf, putbufindex);
    putbufindex = 0;
  }
}

/*---------------------------------------------------------------------------*/

void getty (char *)
//*************************************************************************
//
//*************************************************************************
{
  char s[10];
  wdelay(537);
  s_set(ttyfd, m.ttymode, "lrb");
  t->input = io_tty;
  t->output = io_tty;
  ttysetecho(1);
  while (! runterfahren)
  {
    getlogin(s, 0, "TTY");
    b->sysop = 1;
    mbmain(s, "TTY", "");
    b->quit = 0;
  }
}

/*---------------------------------------------------------------------------*/

void tty_off (void)
//*************************************************************************
//
//*************************************************************************
{
}

/*---------------------------------------------------------------------------*/

void ttysetecho (int echo)
//*************************************************************************
//
//*************************************************************************
{
 /*
  if (echo==2) ttyecho=2;
  if (echo==1) ttyecho=echopreset;
  if (echo==0) ttyecho=0;
  */
}

/*---------------------------------------------------------------------------*/

void init_tty (void)
//*************************************************************************
//
//*************************************************************************
{
  if (*m.ttymode && strcmp(m.ttymode, "/dev/null"))
  {
    ttyfd = open(m.ttymode, /*O_NOCTTY|*/ O_NONBLOCK | O_RDWR);
    if (ttyfd == EOF)
      trace(tr_abbruch, "init_tty", "can't open '%s'\n", m.ttymode);
    trace(report, "init_tty", "start %s", m.ttymode);
    fork(P_MAIL, 0, getty, "getty");
  }
}

/*---------------------------------------------------------------------------*/
#endif
